{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a44ea73b-e592-4947-84e4-704fe9584558",
   "metadata": {
    "id": "a44ea73b-e592-4947-84e4-704fe9584558"
   },
   "source": [
    "1. Create examples of zero vector, one vector, square matrix, diagonal matrix, identity matrix, and symmetric matrix one by one, and represent vectors and matrices with NumPy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ed21b186-cd53-42b7-ae01-31ea283ab77c",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ed21b186-cd53-42b7-ae01-31ea283ab77c",
    "outputId": "efb5e819-7a16-4ac7-f98c-7065cd1f00a4"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Zero vector: [0 0 0]\n"
     ]
    }
   ],
   "source": [
    "# Zero vector\n",
    "import numpy as np\n",
    "zero_vector = np.array([0,0,0])\n",
    "print(\"Zero vector:\",zero_vector)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "82f7c595-da28-4e2f-88fa-8f3caff602a8",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "82f7c595-da28-4e2f-88fa-8f3caff602a8",
    "outputId": "3d0ff446-72e5-4fbb-889e-5e10c904dad2"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "One vector: [1 1 1]\n"
     ]
    }
   ],
   "source": [
    "#One vector\n",
    "one_vector = np.array([1,1,1])\n",
    "print(\"One vector:\",one_vector)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "98edfbf1-8e2f-44fe-b972-b7afaee64b40",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "98edfbf1-8e2f-44fe-b972-b7afaee64b40",
    "outputId": "692023d2-1cde-46c1-c472-6be387ffa740"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Square Matrix:\n",
      " [[1 2]\n",
      " [3 4]]\n"
     ]
    }
   ],
   "source": [
    "#S quare matrix\n",
    "square_matrix = np.array([\n",
    "    [1, 2],\n",
    "    [3, 4]\n",
    "])\n",
    "print(\"Square Matrix:\\n\", square_matrix)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "af428417-c657-4c78-ac97-31dd61a51061",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "af428417-c657-4c78-ac97-31dd61a51061",
    "outputId": "e86f85e8-3f3a-4fb7-d7ac-3e314813a1fa"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Diagonal Matrix:\n",
      " [[1 0 0]\n",
      " [0 2 0]\n",
      " [0 0 3]]\n"
     ]
    }
   ],
   "source": [
    "#Diagonal Matrix\n",
    "diagonal_matrix = np.diag([1, 2, 3])\n",
    "print(\"Diagonal Matrix:\\n\", diagonal_matrix)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "5a9cc1f1-b5ef-4d7c-84e1-eb1dcea07c5a",
   "metadata": {
    "id": "5a9cc1f1-b5ef-4d7c-84e1-eb1dcea07c5a"
   },
   "outputs": [],
   "source": [
    "#Identity Matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "4d93e640-8c9a-4d87-a0c1-3ad354feda7f",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "4d93e640-8c9a-4d87-a0c1-3ad354feda7f",
    "outputId": "abcb3ae4-a260-45ce-9f8b-b10a0981ab43"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Identity Matrix:\n",
      " [[1. 0. 0.]\n",
      " [0. 1. 0.]\n",
      " [0. 0. 1.]]\n"
     ]
    }
   ],
   "source": [
    "identity_matrix = np.eye(3)\n",
    "print(\"Identity Matrix:\\n\", identity_matrix)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ea0ef96e-4e3f-4f5f-b217-f086787a4e7c",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ea0ef96e-4e3f-4f5f-b217-f086787a4e7c",
    "outputId": "e4b7e52e-c164-4797-9def-9b08f5c35a50"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Symmetric Matrix:\n",
      " [[1 2 3]\n",
      " [2 4 5]\n",
      " [3 5 6]]\n"
     ]
    }
   ],
   "source": [
    "#Symmetric Matrix\n",
    "symmetric_matrix = np.array([\n",
    "    [1, 2, 3],\n",
    "    [2, 4, 5],\n",
    "    [3, 5, 6]\n",
    "])\n",
    "print(\"Symmetric Matrix:\\n\", symmetric_matrix)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b03a8964-3ddb-4686-807e-0fdc9075d621",
   "metadata": {
    "id": "b03a8964-3ddb-4686-807e-0fdc9075d621"
   },
   "source": [
    "2.\tThe shares of three companies A, B, and C are 1 million won, 800,000 won, and 500,000 won, respectively. We want to find the amount required to purchase 3, 4, and 5 shares of these stocks, respectively.\n",
    "  \n",
    "            1)Express the stocks‚Äô price and quantity as p vector and n vector, respectively and coded with NumPy.\n",
    "  \n",
    "            2)The amount required to purchase stocks is expressed by multiplication, and the value is calculated by Numpy operation.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fd52e09d-2b35-4d1a-b3be-8252270abbf5",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "fd52e09d-2b35-4d1a-b3be-8252270abbf5",
    "outputId": "f03fe2ab-1291-47cc-a04b-fd4441939c12"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Price vector p: [1000000  800000  500000]\n",
      "Quantity vector n: [3 4 5]\n"
     ]
    }
   ],
   "source": [
    "# 1.\n",
    "import numpy as np\n",
    "\n",
    "# Price vector\n",
    "p = np.array([1_000_000, 800_000, 500_000])\n",
    "\n",
    "# Quantity vector (number of shares)\n",
    "n = np.array([3, 4, 5])\n",
    "\n",
    "print(\"Price vector p:\", p)\n",
    "print(\"Quantity vector n:\", n)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "ee6dc2c8-851c-4ae8-9175-c9a22ae3a496",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ee6dc2c8-851c-4ae8-9175-c9a22ae3a496",
    "outputId": "c193e8ba-5093-450f-e291-699b079be48c"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total amount required (won): 8700000\n"
     ]
    }
   ],
   "source": [
    "# 2.\n",
    "# Total Cost = p.n\n",
    "total_amount = np.dot(p, n) #np.dot is a NumPy function used to calculate the dot product\n",
    "\n",
    "print(\"Total amount required (won):\", total_amount)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e3d7cd54-b72b-410f-ba63-77d6e41546ec",
   "metadata": {
    "id": "e3d7cd54-b72b-410f-ba63-77d6e41546ec"
   },
   "source": [
    "Note:-\n",
    "\n",
    "    (1,000,000 * 3) + (800,000 * 4) + (500000 * 5)\n",
    "    = 3,000,000 + 3,200,000 + 2,500,000\n",
    "    =8,700,000\n",
    "          "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb8d2953-e036-4b07-9a98-10d23f64ca98",
   "metadata": {
    "id": "bb8d2953-e036-4b07-9a98-10d23f64ca98"
   },
   "source": [
    "3. When the following code is executed, all data of the MNIST numeric image is converted into vectors to create a single NumPy matrix X. Use this matrix to solve the following problem.\n",
    " from sklearn.datasets import load_digits\n",
    " X=load_digits().data\n",
    "\n",
    "        1) Find the similarity between the first image and the tenth image using dot product.\n",
    "\n",
    "\n",
    "        2) Find the similarity for a combination of all images using the dot product, how would it be efficient to implement it (hint: using matrices and multiplication of matrices).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "451f0e96-ff5b-486e-81c2-b7b73e3766b3",
   "metadata": {
    "id": "451f0e96-ff5b-486e-81c2-b7b73e3766b3"
   },
   "outputs": [],
   "source": [
    "from sklearn.datasets import load_digits\n",
    "X = load_digits().data # X is a numpy matrix\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "68bbf0e9-0a49-4f8e-89b9-660603978be3",
   "metadata": {
    "id": "68bbf0e9-0a49-4f8e-89b9-660603978be3"
   },
   "outputs": [],
   "source": [
    "# 1.\n",
    "x1 = X[0]   # first image vector\n",
    "x10 = X[9] # tenth image vector\n",
    "#This is because Python uses zero-based indexing\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8a327358-106a-42b2-8f1c-f341028d45e5",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "8a327358-106a-42b2-8f1c-f341028d45e5",
    "outputId": "0bbb3106-726b-46a0-a4d9-09f72001b66e"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Similarity between first and tenth image: 2807.0\n"
     ]
    }
   ],
   "source": [
    "similarity_1_10 = np.dot(x1, x10)\n",
    "print(\"Similarity between first and tenth image:\", similarity_1_10)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9eb876c8-3f57-498c-bb21-528b4ace5bcd",
   "metadata": {
    "id": "9eb876c8-3f57-498c-bb21-528b4ace5bcd"
   },
   "source": [
    "# Note\n",
    "          1.Dot product measures similarity\n",
    "          Higher value ‚Üí more similar\n",
    "          Lower value ‚Üí less similar\n",
    "\n",
    "          similarity=x1‚Äã‚ãÖx10‚Äã"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "db981bcf-fc9c-4e2d-a2e4-19fecf52fd86",
   "metadata": {
    "id": "db981bcf-fc9c-4e2d-a2e4-19fecf52fd86"
   },
   "outputs": [],
   "source": [
    "# 2\n",
    "similarity_matrix = np.dot(X, X.T) # use matrix multiplication.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "20b2b244-05a2-4987-8c73-18fc697ba45f",
   "metadata": {
    "id": "20b2b244-05a2-4987-8c73-18fc697ba45f"
   },
   "source": [
    "4.\tCalculate the following inverse matrix.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "ce8e581b-39ce-4d5d-b32c-8503789d699c",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ce8e581b-39ce-4d5d-b32c-8503789d699c",
    "outputId": "f7f408b8-0f50-4152-ca9e-c012f20d3477"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.5 0. ]\n",
      " [0.  1. ]]\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "A = np.array([[2, 0],\n",
    "              [0, 1]])\n",
    "\n",
    "A_inv = np.linalg.inv(A) #linalg stands for Linear Algebra\n",
    "print(A_inv)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "8c08d5d0-4ada-4e5a-8375-4e8ca3e1d2fc",
   "metadata": {
    "id": "8c08d5d0-4ada-4e5a-8375-4e8ca3e1d2fc"
   },
   "outputs": [],
   "source": [
    "# or\n",
    "B = np.array([[1, 2],\n",
    "              [3, 4]])\n",
    "\n",
    "det = B[0,0]*B[1,1] - B[0,1]*B[1,0]\n",
    "B_inv = (1/det) * np.array([[B[1,1], -B[0,1]],\n",
    "                            [-B[1,0], B[0,0]]])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1310b26d-51bb-4503-991c-3b90461b8a72",
   "metadata": {
    "id": "1310b26d-51bb-4503-991c-3b90461b8a72"
   },
   "source": [
    "#5\n",
    "The Boston house price problem is a problem of predicting the housing price of each town in Boston, USA using features such as the crime rate and air pollution in the area. It can be imported from the load_boston function. Find the weight vector x when the Boston house price problem is solved with the linear prediction model Ax=b ÃÇ. Matrix and vector data can be obtained as follows.\n",
    "\n",
    "Here, to simplify the problem, we limited the input data to crime rate (CRIM), air quality (NOX), number of rooms (RM), and age (AGE), and only four data were used.\n",
    "\n",
    "Run the code below to check whether the magnitude or sign of the weight vector obtained from running the program is consistent the common notion. In order to find it, interpret the printed output for all the factors: CRIM, NOX, RM and AGE.\n",
    "‚Äª Write the interpreted output like ‚Äúthe house price is in inverse proportion to the crime rate (CRIM).‚Äù\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "3c842756-1839-438f-8b00-56ba41ebc1f6",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "3c842756-1839-438f-8b00-56ba41ebc1f6",
    "outputId": "7c60f00b-35de-4816-fe06-e15c5c0c82e1"
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<>:25: SyntaxWarning: invalid escape sequence '\\s'\n",
      "<>:25: SyntaxWarning: invalid escape sequence '\\s'\n",
      "/tmp/ipython-input-1749319742.py:25: SyntaxWarning: invalid escape sequence '\\s'\n",
      "  sep=\"\\s+\",\n",
      "/usr/local/lib/python3.12/dist-packages/urllib3/connectionpool.py:1097: InsecureRequestWarning: Unverified HTTPS request is being made to host 'lib.stat.cmu.edu'. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#tls-warnings\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DataFrame shape: (506, 14)\n",
      "\n",
      "Columns: ['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV']\n",
      "\n",
      "First 3 rows:\n",
      "      CRIM    ZN  INDUS  CHAS    NOX     RM   AGE     DIS  RAD    TAX  \\\n",
      "0  0.00632  18.0   2.31   0.0  0.538  6.575  65.2  4.0900  1.0  296.0   \n",
      "1  0.02731   0.0   7.07   0.0  0.469  6.421  78.9  4.9671  2.0  242.0   \n",
      "2  0.02729   0.0   7.07   0.0  0.469  7.185  61.1  4.9671  2.0  242.0   \n",
      "\n",
      "   PTRATIO       B  LSTAT  MEDV  \n",
      "0     15.3  396.90   4.98  24.0  \n",
      "1     17.8  396.90   9.14  21.6  \n",
      "2     17.8  392.83   4.03  34.7  \n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import requests\n",
    "from io import StringIO\n",
    "\n",
    "def load_boston():\n",
    "    data_url = \"https://lib.stat.cmu.edu/datasets/boston\"\n",
    "\n",
    "    # Get data with requests\n",
    "    response = requests.get(data_url, verify=False)\n",
    "    content = response.text\n",
    "\n",
    "    # Boston dataset column names\n",
    "    feature_names = [\n",
    "        'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE',\n",
    "        'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT'\n",
    "    ]\n",
    "\n",
    "    # Process the text content\n",
    "    lines = content.strip().split('\\n')\n",
    "    data_lines = lines[22:]  # Skip first 22 rows\n",
    "\n",
    "    # Create DataFrame from text\n",
    "    raw_df = pd.read_csv(StringIO('\\n'.join(data_lines)),\n",
    "                         sep=\"\\s+\",\n",
    "                         header=None)\n",
    "\n",
    "    # Restructure data\n",
    "    data = np.hstack([raw_df.values[::2, :], raw_df.values[1::2, :2]])\n",
    "    target = raw_df.values[1::2, 2]\n",
    "\n",
    "    # Create DataFrame with features and target\n",
    "    df = pd.DataFrame(data, columns=feature_names)\n",
    "    df['MEDV'] = target\n",
    "\n",
    "    return df\n",
    "\n",
    "# Load the data\n",
    "boston_df = load_boston()\n",
    "\n",
    "# Display basic info\n",
    "print(f\"DataFrame shape: {boston_df.shape}\")\n",
    "print(f\"\\nColumns: {boston_df.columns.tolist()}\")\n",
    "print(f\"\\nFirst 3 rows:\\n{boston_df.head(3)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "66f31b6d-3fd5-4315-b84c-f3f409260aed",
   "metadata": {
    "id": "66f31b6d-3fd5-4315-b84c-f3f409260aed"
   },
   "outputs": [],
   "source": [
    "boston_df\n",
    "# If MEDV is the last column and you want it as target\n",
    "X = boston_df.iloc[:, :-1]  # All rows, all columns except last\n",
    "y = boston_df.iloc[:, -1]   # All rows, only last column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "274122fb-fa14-4add-8221-8ed3ac0a1697",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "274122fb-fa14-4add-8221-8ed3ac0a1697",
    "outputId": "f570712c-2c0a-4bf3-d87c-8979c707d0dc"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(        CRIM    ZN  INDUS  CHAS    NOX     RM   AGE     DIS  RAD    TAX  \\\n",
       " 0    0.00632  18.0   2.31   0.0  0.538  6.575  65.2  4.0900  1.0  296.0   \n",
       " 1    0.02731   0.0   7.07   0.0  0.469  6.421  78.9  4.9671  2.0  242.0   \n",
       " 2    0.02729   0.0   7.07   0.0  0.469  7.185  61.1  4.9671  2.0  242.0   \n",
       " 3    0.03237   0.0   2.18   0.0  0.458  6.998  45.8  6.0622  3.0  222.0   \n",
       " 4    0.06905   0.0   2.18   0.0  0.458  7.147  54.2  6.0622  3.0  222.0   \n",
       " ..       ...   ...    ...   ...    ...    ...   ...     ...  ...    ...   \n",
       " 501  0.06263   0.0  11.93   0.0  0.573  6.593  69.1  2.4786  1.0  273.0   \n",
       " 502  0.04527   0.0  11.93   0.0  0.573  6.120  76.7  2.2875  1.0  273.0   \n",
       " 503  0.06076   0.0  11.93   0.0  0.573  6.976  91.0  2.1675  1.0  273.0   \n",
       " 504  0.10959   0.0  11.93   0.0  0.573  6.794  89.3  2.3889  1.0  273.0   \n",
       " 505  0.04741   0.0  11.93   0.0  0.573  6.030  80.8  2.5050  1.0  273.0   \n",
       " \n",
       "      PTRATIO       B  LSTAT  \n",
       " 0       15.3  396.90   4.98  \n",
       " 1       17.8  396.90   9.14  \n",
       " 2       17.8  392.83   4.03  \n",
       " 3       18.7  394.63   2.94  \n",
       " 4       18.7  396.90   5.33  \n",
       " ..       ...     ...    ...  \n",
       " 501     21.0  391.99   9.67  \n",
       " 502     21.0  396.90   9.08  \n",
       " 503     21.0  396.90   5.64  \n",
       " 504     21.0  393.45   6.48  \n",
       " 505     21.0  396.90   7.88  \n",
       " \n",
       " [506 rows x 13 columns],\n",
       " 0      24.0\n",
       " 1      21.6\n",
       " 2      34.7\n",
       " 3      33.4\n",
       " 4      36.2\n",
       "        ... \n",
       " 501    22.4\n",
       " 502    20.6\n",
       " 503    23.9\n",
       " 504    22.0\n",
       " 505    11.9\n",
       " Name: MEDV, Length: 506, dtype: float64)"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "X,y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "7a61b705-2ee3-4f67-a2e9-c0e20e833bdf",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "7a61b705-2ee3-4f67-a2e9-c0e20e833bdf",
    "outputId": "9418c95c-3427-4f21-caa5-8db3256f4f6f"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of weights (including intercept): 14\n",
      "Weight vector w: [ 3.64594884e+01 -1.08011358e-01  4.64204584e-02  2.05586264e-02\n",
      "  2.68673382e+00 -1.77666112e+01  3.80986521e+00  6.92224640e-04\n",
      " -1.47556685e+00  3.06049479e-01 -1.23345939e-02 -9.52747232e-01\n",
      "  9.31168327e-03 -5.24758378e-01]\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "# Assuming boston_df is your DataFrame with all columns including MEDV\n",
    "# Separate features (X) and target (y)\n",
    "X = boston_df.iloc[:, :-1].values  # Convert to numpy array\n",
    "y = boston_df.iloc[:, -1].values   # Convert to numpy array\n",
    "\n",
    "# Add a column of ones for the intercept term (bias term)\n",
    "# This makes the equation: w‚ÇÄ + w‚ÇÅx‚ÇÅ + w‚ÇÇx‚ÇÇ + ... + w‚Çôx‚Çô\n",
    "X_with_intercept = np.c_[np.ones(X.shape[0]), X]  # Add column of ones\n",
    "\n",
    "# Calculate the weight vector using normal equation\n",
    "# w = (X·µÄX)‚Åª¬πX·µÄy\n",
    "X_transpose = X_with_intercept.T\n",
    "w = np.linalg.inv(X_transpose @ X_with_intercept) @ X_transpose @ y\n",
    "\n",
    "print(f\"Number of weights (including intercept): {len(w)}\")\n",
    "print(f\"Weight vector w: {w}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "82e60bf0-0d75-4e6f-bf67-b64116ee7dd2",
   "metadata": {
    "id": "82e60bf0-0d75-4e6f-bf67-b64116ee7dd2"
   },
   "source": [
    "6.\tFind the weight vector w when the Boston house price problem is solved with the linear prediction model X_w = y ÃÇ by the least-squares method. Matrix and vector data can be obtained as follows.\n",
    "‚Äª This question is related to Question 5.\n",
    "\n",
    "         import pandas as pd\n",
    "         import numpy as np\n",
    "\n",
    "         def load_boston():\n",
    "         data_url = \"http://lib.stat.cmu.edu/datasets/boston\"\n",
    "         raw_df = pd.read_csv(data_url, sep=\"\\s+\", skiprows=22,    header=None)\n",
    "         data = np.hstack([raw_df.values[::2, :], raw_df.values[1::2, :2]])\n",
    "         target = raw_df.values[1::2, 2]\n",
    "         return {'data': data, 'target': target}\n",
    "\n",
    "\n",
    "         boston=load_boston()\n",
    "         X=boston[‚Äòdata‚Äô]\n",
    "         y=boston[‚Äòtarget‚Äô]\n",
    "\n",
    "The meaning of each column of matrix X is as follows.\n",
    "\n",
    "        ‚àô\tCRIM: crime rate\n",
    "        ‚àô\tINDUS: Non-retail commercial area ratio\n",
    "        ‚àô\tNOX: Nitric Oxide Concentration\n",
    "        ‚àô\tRM: Number of rooms per house\n",
    "        ‚àô\tLSTAT: Proportion of the lower class of the population\n",
    "        ‚àô\tB: Proportion of black people in the population\n",
    "        ‚àô\tPTRATIO: Student/Teacher Ratio\n",
    "        ‚àô\tZN: Percentage of residential areas exceeding 25,000 square feet\n",
    "        ‚àô\tCHAS: 1 if located on the Charles River border, 0 otherwise\n",
    "        ‚àô\tAGE: Percentage of houses built before 1940\n",
    "        ‚àô\tRAD: Distance to radial highway\n",
    "        ‚àô\tDIS: Weighted average distance to 5 Boston Job Centers\n",
    "        ‚àô\tTAX: property tax rate\n",
    "\n",
    "1)\tRun the program above to check whether the magnitude or sign of the weight vector obtained from running the program is consistent the common notion. In order to find it, interpret the printed output for all the factors suggested above.\n",
    "‚Äª Write the interpreted output like ‚Äúthe house price is in inverse proportion to the crime rate (CRIM)‚Äù.\n",
    "\n",
    "2)\tExplain how the result differs from the value obtained in Question 5.\n",
    "![image.png](attachment:2de169fb-135a-4411-a368-7a5b349052e4.png)!\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "649ff8cb-cd0a-401e-8d8a-95f9a16c3375",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "649ff8cb-cd0a-401e-8d8a-95f9a16c3375",
    "outputId": "f1ca129c-d260-4ddd-f288-9e6f6d7bcc08"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "LINEAR REGRESSION WEIGHT VECTOR ANALYSIS\n",
      "============================================================\n",
      "\n",
      "Number of weights: 14\n",
      "Weight vector w:\n",
      "\n",
      " 0. Intercept :  36.459488  [Intercept/Baseline price when all features are zero]\n",
      " 1. CRIM      :  -0.108011  [Negative correlation with house price]\n",
      " 2. ZN        :   0.046420  [Negligible effect]\n",
      " 3. INDUS     :   0.020559  [Negligible effect]\n",
      " 4. CHAS      :   2.686734  [Positive correlation with house price]\n",
      " 5. NOX       : -17.766611  [Negative correlation with house price]\n",
      " 6. RM        :   3.809865  [Positive correlation with house price]\n",
      " 7. AGE       :   0.000692  [Negligible effect]\n",
      " 8. DIS       :  -1.475567  [Negative correlation with house price]\n",
      " 9. RAD       :   0.306049  [Positive correlation with house price]\n",
      "10. TAX       :  -0.012335  [Negligible effect]\n",
      "11. PTRATIO   :  -0.952747  [Negative correlation with house price]\n",
      "12. B         :   0.009312  [Negligible effect]\n",
      "13. LSTAT     :  -0.524758  [Negative correlation with house price]\n",
      "\n",
      "============================================================\n",
      "INTERPRETATION OF FACTORS:\n",
      "============================================================\n",
      " 1. The house price is in inverse proportion to CRIM (weight: -0.108011)\n",
      " 2. The house price is in direct proportion to ZN (weight: 0.046420)\n",
      " 3. The house price is in direct proportion to INDUS (weight: 0.020559)\n",
      " 4. The house price is in direct proportion to CHAS (weight: 2.686734)\n",
      " 5. The house price is in inverse proportion to NOX (weight: -17.766611)\n",
      " 6. The house price is in direct proportion to RM (weight: 3.809865)\n",
      " 7. The house price is in direct proportion to AGE (weight: 0.000692)\n",
      " 8. The house price is in inverse proportion to DIS (weight: -1.475567)\n",
      " 9. The house price is in direct proportion to RAD (weight: 0.306049)\n",
      "10. The house price is in inverse proportion to TAX (weight: -0.012335)\n",
      "11. The house price is in inverse proportion to PTRATIO (weight: -0.952747)\n",
      "12. The house price is in direct proportion to B (weight: 0.009312)\n",
      "13. The house price is in inverse proportion to LSTAT (weight: -0.524758)\n"
     ]
    }
   ],
   "source": [
    "# import numpy as np\n",
    "# import pandas as pd\n",
    "\n",
    "# # Assuming boston_df is already loaded\n",
    "# # Separate features (X) and target (y)\n",
    "# X = boston_df.iloc[:, :-1].values  # All features\n",
    "# y = boston_df.iloc[:, -1].values   # Target (MEDV)\n",
    "\n",
    "# # Add intercept term\n",
    "# X_with_intercept = np.c_[np.ones(X.shape[0]), X]\n",
    "\n",
    "# Calculate weight vector using normal equation\n",
    "w = np.linalg.inv(X_with_intercept.T @ X_with_intercept) @ X_with_intercept.T @ y\n",
    "\n",
    "# Print results with interpretation\n",
    "feature_names = ['Intercept'] + list(boston_df.columns[:-1])\n",
    "\n",
    "print(\"=\"*60)\n",
    "print(\"LINEAR REGRESSION WEIGHT VECTOR ANALYSIS\")\n",
    "print(\"=\"*60)\n",
    "print(f\"\\nNumber of weights: {len(w)}\")\n",
    "print(f\"Weight vector w:\\n\")\n",
    "\n",
    "for i, (name, weight) in enumerate(zip(feature_names, w)):\n",
    "    print(f\"{i:2d}. {name:10s}: {weight:10.6f}\", end=\"  \")\n",
    "\n",
    "    if i == 0:\n",
    "        print(\"[Intercept/Baseline price when all features are zero]\")\n",
    "    else:\n",
    "        if abs(weight) < 0.1:\n",
    "            print(\"[Negligible effect]\")\n",
    "        elif weight > 0:\n",
    "            print(\"[Positive correlation with house price]\")\n",
    "        else:\n",
    "            print(\"[Negative correlation with house price]\")\n",
    "\n",
    "print(\"\\n\" + \"=\"*60)\n",
    "print(\"INTERPRETATION OF FACTORS:\")\n",
    "print(\"=\"*60)\n",
    "\n",
    "# Interpretation based on weights\n",
    "interpretations = []\n",
    "for name, weight in zip(boston_df.columns[:-1], w[1:]):\n",
    "    if weight > 0:\n",
    "        interpretations.append(f\"The house price is in direct proportion to {name}\")\n",
    "    else:\n",
    "        interpretations.append(f\"The house price is in inverse proportion to {name}\")\n",
    "\n",
    "# Print interpretations\n",
    "for i, interpretation in enumerate(interpretations, 1):\n",
    "    print(f\"{i:2d}. {interpretation} (weight: {w[i]:.6f})\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "83139224-6fcd-4f48-87e2-0bdcf4e014af",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "83139224-6fcd-4f48-87e2-0bdcf4e014af",
    "outputId": "b635c931-d547-451f-d2ce-15c736d40d68"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Euclidean distance a-b: 5.385164807134504\n",
      "Euclidean distance a-c: 4.242640687119285\n",
      "Euclidean distance b-c: 3.605551275463989\n"
     ]
    }
   ],
   "source": [
    "# 1.\n",
    "import numpy as np\n",
    "\n",
    "a = np.array([4, 5, 2, 2])\n",
    "b = np.array([4, 0, 2, 0])\n",
    "c = np.array([2, 2, 0, 1])\n",
    "\n",
    "# Euclidean distances\n",
    "d_ab = np.linalg.norm(a - b) # np.linalg.norm is used to calculate the Euclidean length (magnitude) of a vector or distance between two vectors\n",
    "d_ac = np.linalg.norm(a - c)\n",
    "d_bc = np.linalg.norm(b - c)\n",
    "\n",
    "print(\"Euclidean distance a-b:\", d_ab)\n",
    "print(\"Euclidean distance a-c:\", d_ac)\n",
    "print(\"Euclidean distance b-c:\", d_bc) #Euclidean distance ka matlab hota hai do points (ya do vectors) ke beech ki seedhi (straight-line) distance.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7792f88-86b7-4034-ae1e-83fc80900b1d",
   "metadata": {
    "id": "f7792f88-86b7-4034-ae1e-83fc80900b1d"
   },
   "source": [
    "#NOTE\n",
    ":- 1) Euclidean Distance\n",
    "Formula\n",
    "ùëë\n",
    "(\n",
    "ùë•\n",
    ",\n",
    "ùë¶\n",
    ")\n",
    "=\n",
    "‚àë\n",
    "(\n",
    "ùë•\n",
    "ùëñ\n",
    "‚àí\n",
    "ùë¶\n",
    "ùëñ\n",
    ")\n",
    "2\n",
    "d(x,y)=\n",
    "‚àë(x\n",
    "i\n",
    "\t‚Äã\n",
    "\n",
    "‚àíy\n",
    "i\n",
    "\t‚Äã\n",
    "\n",
    ")\n",
    "2\n",
    "\t‚Äã\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "324da7c0-29c1-4dbb-9685-7b68089ac0b3",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "324da7c0-29c1-4dbb-9685-7b68089ac0b3",
    "outputId": "1a07c51f-89a5-4c4f-c293-9b0932e5fd09"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cosine distance a-b: 0.36112343500006017\n",
      "Cosine distance a-c: 0.04761904761904767\n",
      "Cosine distance b-c: 0.40371520600005606\n"
     ]
    }
   ],
   "source": [
    "# 2.\n",
    "\n",
    "def cosine_distance(x, y):\n",
    "    similarity = np.dot(x, y) / (np.linalg.norm(x) * np.linalg.norm(y))\n",
    "    return 1 - similarity\n",
    "\n",
    "cd_ab = cosine_distance(a, b)\n",
    "cd_ac = cosine_distance(a, c)\n",
    "cd_bc = cosine_distance(b, c)\n",
    "\n",
    "print(\"Cosine distance a-b:\", cd_ab)\n",
    "print(\"Cosine distance a-c:\", cd_ac)\n",
    "print(\"Cosine distance b-c:\", cd_bc)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cfe3810-35a5-4c57-99e8-24d09b61635a",
   "metadata": {
    "id": "7cfe3810-35a5-4c57-99e8-24d09b61635a"
   },
   "source": [
    "#Note\n",
    "2) Cosine Distance\n",
    "Formula\n",
    "\n",
    "Cosine similarity:\n",
    "\n",
    "cos\n",
    "‚Å°\n",
    "(\n",
    "ùúÉ\n",
    ")\n",
    "=\n",
    "ùë•\n",
    "‚ãÖ\n",
    "ùë¶\n",
    "‚à•\n",
    "ùë•\n",
    "‚à•\n",
    "‚à•\n",
    "ùë¶\n",
    "‚à•\n",
    "cos(Œ∏)=\n",
    "‚à•x‚à•‚à•y‚à•\n",
    "x‚ãÖy\n",
    "\t‚Äã\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Cosine distance\n",
    "=\n",
    "1\n",
    "‚àí\n",
    "cos\n",
    "‚Å°\n",
    "(\n",
    "ùúÉ\n",
    ")\n",
    "Cosine distance=1‚àícos(Œ∏)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc4a53d1-1897-4fa0-920c-1ecb253cdfc4",
   "metadata": {
    "id": "cc4a53d1-1897-4fa0-920c-1ecb253cdfc4"
   },
   "source": [
    "#8. \tFind the eigenvalues of the following matrix using the characteristic equation.\n",
    "\n",
    "D=[‚ñ†(2&1@1&2)]\n",
    "![image.png](attachment:0535476e-8f12-4527-9ee8-780347741996.png)!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "c24aa667-76b1-4057-bf43-2ad4a2008fc0",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "c24aa667-76b1-4057-bf43-2ad4a2008fc0",
    "outputId": "c89ff904-f687-4a20-e656-d8ddf8c47ea8"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Characteristic Equation:\n",
      "lam**2 - 4*lam + 3\n",
      "\n",
      "Eigenvalues:\n",
      "[1, 3]\n"
     ]
    }
   ],
   "source": [
    "import sympy as sp\n",
    "\n",
    "# Define the symbol lambda\n",
    "lam = sp.symbols('lam')\n",
    "\n",
    "# Define the matrix D\n",
    "D = sp.Matrix([[2, 1],\n",
    "               [1, 2]])\n",
    "\n",
    "# Identity matrix\n",
    "I = sp.eye(2)\n",
    "\n",
    "# Characteristic equation: |D - ŒªI| = 0\n",
    "char_eq = (D - lam * I).det()\n",
    "\n",
    "print(\"Characteristic Equation:\")\n",
    "print(char_eq)\n",
    "\n",
    "# Solve for eigenvalues\n",
    "eigenvalues = sp.solve(char_eq, lam)\n",
    "\n",
    "print(\"\\nEigenvalues:\")\n",
    "print(eigenvalues)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "a1878708-db37-4d28-92c9-25d2bd521a2c",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "a1878708-db37-4d28-92c9-25d2bd521a2c",
    "outputId": "50d5a4b9-055b-4159-ce5b-e03d70bda08b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.14.0\n"
     ]
    }
   ],
   "source": [
    "import sympy\n",
    "print(sympy.__version__)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "2a122fae-a782-4c1e-b6ec-b6fe6c5eba3e",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "2a122fae-a782-4c1e-b6ec-b6fe6c5eba3e",
    "outputId": "ff5a6904-bed0-4244-a910-6f1f6f13104f"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Characteristic Equation:\n",
      "lam**2 - 4*lam + 3\n",
      "\n",
      "Eigenvalues:\n",
      "[1, 3]\n"
     ]
    }
   ],
   "source": [
    "import sympy as sp\n",
    "# import sys\n",
    "lam = sp.symbols('lam')\n",
    "\n",
    "# Define the matrix D\n",
    "D = sp.Matrix([[2, 1],\n",
    "               [1, 2]])\n",
    "\n",
    "# Identity matrix\n",
    "I = sp.eye(2)\n",
    "\n",
    "# Characteristic equation: |D - ŒªI| = 0\n",
    "char_eq = (D - lam * I).det()\n",
    "\n",
    "print(\"Characteristic Equation:\")\n",
    "print(char_eq)\n",
    "\n",
    "# Solve for eigenvalues\n",
    "eigenvalues = sp.solve(char_eq, lam)\n",
    "\n",
    "print(\"\\nEigenvalues:\")\n",
    "print(eigenvalues)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "fb1533ad-9c53-4e21-880e-97ff005d5421",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "fb1533ad-9c53-4e21-880e-97ff005d5421",
    "outputId": "45048be5-35e0-4eba-ff7e-b28a2d9e85f8"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "log 12 =  2.48\n"
     ]
    }
   ],
   "source": [
    "#9\n",
    "# Given log values\n",
    "log2 = 0.69\n",
    "log3 = 1.10\n",
    "\n",
    "# Calculate log12 using log properties: log(12) = log(2^2 * 3) = 2*log2 + log3\n",
    "log12 = 2 * log2 + log3\n",
    "\n",
    "print(\"log 12 = \", log12)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "8e31cc10-437d-4bb5-a49f-213e41610564",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "8e31cc10-437d-4bb5-a49f-213e41610564",
    "outputId": "b57b19f8-4db1-4289-8fc9-21ebab934f12"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-2.19722458  0.          2.19722458]\n"
     ]
    }
   ],
   "source": [
    "# 10\n",
    "import numpy as np\n",
    "\n",
    "def logistic_inverse_np(y):\n",
    "    y = np.array(y)\n",
    "    if np.any((y <= 0) | (y >= 1)):\n",
    "        raise ValueError(\"All elements of y must be between 0 and 1 (exclusive).\")\n",
    "    return np.log(y / (1 - y))\n",
    "\n",
    "# Example with array\n",
    "y_values = [0.1, 0.5, 0.9]\n",
    "x_values = logistic_inverse_np(y_values)\n",
    "print(x_values)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "a2b53c3e-bf2a-4bc3-a702-98cd1c9290b4",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "a2b53c3e-bf2a-4bc3-a702-98cd1c9290b4",
    "outputId": "ff599c5e-5f50-4d33-81e4-25dfc2cf1cd7"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Derivative of f1: 3*x**2\n",
      "Derivative of f2: 2*x/(-3*k + x**2)\n",
      "Derivative of f3: a*b*x**b*exp(a*x**b)/x\n"
     ]
    }
   ],
   "source": [
    "# 11\n",
    "import sympy as sp\n",
    "\n",
    "# Define the variable and constants\n",
    "x = sp.symbols('x')\n",
    "k, a, b = sp.symbols('k a b')\n",
    "\n",
    "# Function 1: f(x) = x^3 - 1\n",
    "f1 = x**3 - 1\n",
    "df1 = sp.diff(f1, x)\n",
    "print(\"Derivative of f1:\", df1)\n",
    "\n",
    "# Function 2: f(x) = log(x^2 - 3k)\n",
    "f2 = sp.log(x**2 - 3*k)\n",
    "df2 = sp.diff(f2, x)\n",
    "print(\"Derivative of f2:\", df2)\n",
    "\n",
    "# Function 3: f(x) = exp(a*x^b)\n",
    "f3 = sp.exp(a * x**b)\n",
    "df3 = sp.diff(f3, x)\n",
    "print(\"Derivative of f3:\", df3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae8d642d-93ee-48a4-9cef-152e49325883",
   "metadata": {
    "id": "ae8d642d-93ee-48a4-9cef-152e49325883"
   },
   "source": [
    "#12\tFind the first/second partial derivatives f_x,f_y,f_xx,f_xy,f_yx,f_yy for the following function.\n",
    "f(x,y) = exp(x^2+2 y^2)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29961bd8-ce55-40aa-960b-8231b8df910b",
   "metadata": {
    "id": "29961bd8-ce55-40aa-960b-8231b8df910b"
   },
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
